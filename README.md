# Dipstick

Dipstick is a dependency injection framework for TypeScript. Instead of using `@Decorators`, `reflect-metadata`, or unique strings to identify objects to the DI framework, Dipstick relies on the type system and code generation.
The result is a DI framework that works with the strengths of typescript, instead of hacking around it's weaknesses.

**Simple.**

Unlike other DI frameworks, which can sometimes feel like learning an entirely new language, learning Dipstick only requires understanding two concepts: Modules and Bindings.

**Obvious.**

The [principle of least surprise](https://en.wikipedia.org/wiki/Principle_of_least_astonishment) is fundamental to Dipstick. There are no magic decorators or obtuse indirections in code. All of your IDEs tools like "Find references" and "go to symbol" work just as well with Dipstick as without. If you know typescript, understanding the code generated by Dipstick is a piece of cake. 

**Type Safe.**

Dipstick works with the type system, instead of around it. Use the same Module types you declared to generate code in your integration tests to provide mocks for specific Modules. Don't worry about a DI framework spreading `any` throughout your codebase -- the types that come out of Dipstick are exactly as strong as you author them to be.

## Installation

```bash
npm install dipstick
```

## Overview

Dipstick uses TypeScript's type system and code generation to create dependency injection containers. The framework is designed to be type-safe and easy to use, with a focus on maintainability and developer experience.

## Core Concepts

### Modules

Modules are the core building blocks of Dipstick. They allow you to bind implementations to types that are used throughout your project. An instance of a module is akin to a "scope" in other DI frameworks -- the module instance will hold references to [reusable bindings](https://github.com/mako-taco/dipstick/edit/main/README.md#reusable-bindings) and [static bindings](https://github.com/mako-taco/dipstick/edit/main/README.md#static-bindings). To create a module, export a type alias to `dip.Module`, and define its bindings:

```typescript
import { dip } from 'dipstick';

interface IFoo {}
class Foo implements IFoo {}
...

export type MyModule = dip.Module<{
  bindings: {
    foo: dip.Bind.Reusable<Foo, IFoo>;
    bar: dip.Bind.Transient<Bar, IBar>;
    baz: dip.Bind.Reusable<Baz, IBaz>;
  };
}>;
```

### Bindings

Dipstick supports three types of bindings:

#### Reusable Bindings

Reusable bindings return the same instance every time they are called. This is useful for singletons or other objects that should only be created once per module:

```typescript
export type MyModule = dip.Module<{
  bindings: {
    // Returns the same Foo instance every time
    foo: dip.Bind.Reusable<Foo, IFoo>;
  };
}>;
```

#### Transient Bindings

Transient bindings return a new instance every time they are called. This is useful for objects that should be created fresh each time they are requested:

```typescript
export type MyModule = dip.Module<{
  bindings: {
    // Returns a new Bar instance every time
    bar: dip.Bind.Transient<Bar>;
  };
}>;
```

#### Static Bindings

Static bindings are used to provide objects to a module when the module is instantiated. Use static bindings when you want to incorporate an object created outside of dipstick into a module so that it can be used as a dependency of other objects.

```typescript
class RequestHandler {
  constructor(req: Request, res: Response) {}

  execute() {
    res.send(200, `hello ${req.path}`)
  }
}

export type RequestModule = dip.Module<{
  bindings: {
    // Created outside of this module
    req: dip.Bind.Static<Request>;
    res: dip.Bind.Static<Request>;

    requestHandler: dip.Bind.Transient<RequestHandler>
  };
}>;

app.use((req, res) => {
  const module = new MyModule({req, res})
  const handler = module.requestHandler()
  handler.execute()
})
```

#### Binding Implementations to Interfaces

All bindings take two type arguments. The first argumnent must be a class which will be instantiated by the binding. The second, optional argument is a type to return the instance as, such as an interface.

```typescript
export type MyModule = dip.Module<{
  bindings: {
    userIface: dip.Bind.Transient<User, IUser>
    userImpl: dip.Bind.Transient<User>
  }
}>
```

```typescript
const module = new MyModuleImpl()

const userImpl = module.userImpl() // User
const userIface = module.userIface() // IUser
```


### Modularity & Composition

Modules can depend on other modules. These dependencies are used to resolve types that the module cannot resolve itself:

```typescript
class Foo {
  constructor(bar: Bar) {}
}

export type FooModule = dip.Module<{
  bindings: {
    foo: dip.Bind.Reusable<Foo>;
  };
}>;

export type BarModule = dip.Module<{
  dependencies: [ FooModule ];
  bindings: {
    bar: dip.Bind.Transient<Bar>;
  };
}>;

const fooModule = new FooModule()
const barModule = new BarModule([ fooModule ])

// if a module has both dependencies and static bindings, pass both:
// const barModule = new BarModule({ baz: new Baz() }, [ fooModule ])
```

## Usage

1. Define your modules using type aliases to `dip.Module`
2. Run the code generator:
   ```bash
   npm exec -- dipstick generate ./path/to/tsconfig.json --verbose
   ```
3. Use the generated modules in your application:
   ```typescript
   const myModule = new MyModuleImpl();
   const service = myModule.myService();
   ...
   ```

## Code Generation

The code generator will:

1. Scan your TypeScript files for exported module type aliases
2. Generate implementation classes for each module
3. Handle dependency injection and binding resolution
4. Ensure type safety throughout the dependency graph

## Contributing

Contributions are welcome! Please see our [CONTRIBUTORS.md](./CONTRIBUTORS.md) guide for detailed information about:

- Setting up the development environment
- Running tests and code quality checks
- Code style guidelines
- Submitting pull requests

For quick contributions:

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Run `npm run check && npm test`
5. Submit a Pull Request
   `
