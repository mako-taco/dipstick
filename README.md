
[![Chat-GPT-Image-Jun-29-2025-04-26-18-PM.png](https://i.postimg.cc/3xP7tyxd/Chat-GPT-Image-Jun-29-2025-04-26-18-PM.png)](https://postimg.cc/Sn7wsx8h)

Dipstick is a dependency injection framework for TypeScript. Instead of using `@Decorators`, `reflect-metadata`, or unique strings to identify objects to the DI framework, Dipstick relies on the type system and code generation.
The result is a DI framework that works with the strengths of typescript, instead of hacking around it's weaknesses.

**Simple.**

Unlike other DI frameworks, which can sometimes feel like learning an entirely new language, learning Dipstick only requires understanding two concepts: Containers and Bindings.

**Obvious.**

The [principle of least surprise](https://en.wikipedia.org/wiki/Principle_of_least_astonishment) is fundamental to Dipstick. There are no magic decorators or obtuse indirections in code. All of your IDEs tools like "Find references" and "go to symbol" work just as well with Dipstick as without. If you know typescript, understanding the code generated by Dipstick is a piece of cake. 

**Type Safe.**

Dipstick works with the type system, instead of around it. Use the same Container types you declared to generate code in your integration tests to provide mocks for specific Containers. Don't worry about a DI framework spreading `any` throughout your codebase -- the types that come out of Dipstick are exactly as strong as you author them to be.

## Installation

```bash
npm install dipstick
```

## Overview

Dipstick uses TypeScript's type system and code generation to create dependency injection containers. The framework is designed to be type-safe and easy to use, with a focus on maintainability and developer experience.

## Core Concepts

### Containers

Containers are the core building blocks of Dipstick. They allow you to bind implementations to types that are used throughout your project. An instance of a container is akin to a "scope" in other DI frameworks -- the container instance will hold references to [reusable bindings](https://github.com/mako-taco/dipstick/edit/main/README.md#reusable-bindings) and [static bindings](https://github.com/mako-taco/dipstick/edit/main/README.md#static-bindings). To create a container, export a type alias to `Container`, and define its bindings:

```typescript
import { dip } from 'dipstick';

interface IFoo {}
class Foo implements IFoo {}
...

export type MyContainer = Container<{
  bindings: {
    foo: Reusable<Foo, IFoo>;
    bar: Transient<Bar, IBar>;
    baz: Reusable<Baz, IBaz>;
  };
}>;
```

### Bindings

Bindings allow containers to associate an implementation with a type. All bindings take two type arguments. The first argumnent must be a class which will be instantiated by the binding. The second, optional argument is a type to return the instance as, such as an interface. Within a single container, no two bindings may return the same type alias.

```typescript
export type MyContainer = Container<{
  bindings: {
    userIface: Transient<User, IUser>
    userImpl: Transient<User>
  }
}>
```

```typescript
const container = new MyContainerImpl()

const userImpl = container.userImpl() // User
const userIface = container.userIface() // IUser
```

Bindings come in three flavors, which are described below.

#### Reusable Bindings

Reusable bindings return the same instance every time they are called. This is useful for singletons or other objects that should only be created once per container:

```typescript
export type MyContainer = Container<{
  bindings: {
    // Returns the same Foo instance every time
    foo: Reusable<Foo, IFoo>;
  };
}>;
```

#### Transient Bindings

Transient bindings return a new instance every time they are called. This is useful for objects that should be created fresh each time they are requested:

```typescript
export type MyContainer = Container<{
  bindings: {
    // Returns a new Bar instance every time
    bar: Transient<Bar>;
  };
}>;
```

#### Static Bindings

Static bindings are used to provide objects to a container when the container is instantiated. Use static bindings when you want to incorporate an object created outside of dipstick into a container so that it can be used as a dependency of other objects.

```typescript
class RequestHandler {
  constructor(req: Request, res: Response) {}

  execute() {
    res.send(200, `hello ${req.path}`)
  }
}

export type RequestContainer = Container<{
  bindings: {
    // Created outside of this container
    req: Static<Request>;
    res: Static<Request>;

    requestHandler: Transient<RequestHandler>
  };
}>;

app.use((req, res) => {
  const container = new MyContainer({req, res})
  const handler = container.requestHandler()
  handler.execute()
})
```

### Modularity & Composition

Containers can depend on other containers. These dependencies are used to resolve types that the container cannot resolve itself:

```typescript
class Foo {
  constructor(bar: Bar) {}
}

export type FooContainer = Container<{
  bindings: {
    foo: Reusable<Foo>;
  };
}>;

export type BarContainer = Container<{
  dependencies: [ FooContainer ];
  bindings: {
    bar: Transient<Bar>;
  };
}>;

const fooContainer = new FooContainer()
const barContainer = new BarContainer([ fooContainer ])

// if a container has both dependencies and static bindings, pass both:
// const barContainer = new BarContainer({ baz: new Baz() }, [ fooContainer ])
```

## Usage

1. Define your containers using type aliases to `Container`
2. Run the code generator:
   ```bash
   npm exec -- dipstick generate ./path/to/tsconfig.json --verbose
   ```
3. Use the generated containers in your application:
   ```typescript
   const myContainer = new MyContainerImpl();
   const service = myContainer.myService();
   ...
   ```

## Code Generation

The code generator will:

1. Scan your TypeScript files for exported container type aliases
2. Generate implementation classes for each container
3. Handle dependency injection and binding resolution
4. Ensure type safety throughout the dependency graph

## Contributing

Contributions are welcome! Please see our [CONTRIBUTORS.md](./CONTRIBUTORS.md) guide for detailed information about:

- Setting up the development environment
- Running tests and code quality checks
- Code style guidelines
- Submitting pull requests

For quick contributions:

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Run `npm run build && npm run check && npm test`
5. Submit a Pull Request
